/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package zelda_package;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;
import javax.imageio.ImageIO;
import javax.swing.Timer;

/**
 *
 * @author sixten.holmqvist
 */
public class ZeldaPanel extends javax.swing.JPanel {

    //https://www.java67.com/2012/11/how-to-read-file-in-java-using-scanner-example.html
    /**
     * Creates new form ZeldaPanel
     */
    public ZeldaPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    BufferedImage wallSprite = null; //skapar platser för att lägga till bilder
    BufferedImage hart = null;
    BufferedImage getToEgg = null;
    BufferedImage startbtn = null;
    BufferedImage restartbtn = null;
    BufferedImage gameOwer = null;
    BufferedImage egg = null;
    BufferedImage avoidBombs = null;
    BufferedImage wictory = null;
    String filePath; //minne för var spelet ligger på datorn
    int screen = -1; //minne för vilken del av spelet som man är på
    ArrayList<ArrayList<Integer>> map = new ArrayList<>(); //det rummet eller del av hela världen som man är på
    File textDocument; //den .txt fil som lagrar kartan för varge rumm
    int wallLengthY = 11 * 3, wallLengthX = 16 * 3; //storleken för varge rum i Y och X led
    ArrayList<Player> player = new ArrayList<>(); //en ArrayList med spelar klassen
    ArrayList<ArrayList<String>> mapMap = new ArrayList<>(); //en tvådimentionel Arraylist som lagrar vilken karta i .txt dokumentet som hör till vilken position på curentMap arrayn
    int[] curentMap = {1, 1}; //minne för vilket rumm som spelaren är på
    int enemyPause = 0; //används för att få fienden att bara gå varanan runda
    int moveDirektion = 0; //används för att komma ihåg vilken riktning spelaren tryckt på 
    ArrayList<Enemie> enemies = new ArrayList<>(); //ArrayList för fiende klassen
    ArrayList<ArrayList<Integer>> turns = new ArrayList<>();//tvådimentionell ArrayList för minne av poäng och vilken runda de poängen blev givna
    int atempt = -1; //minne för hur många gånger spelet har spelats

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        repaint();
        switch (screen) { //varge case är olika stdier i spelet som visas: -1=innan spelet börgat, 0=startskermen, 1=spelplanen, 2=förlora skermen, 3=vinnst skermen
            case -1 -> {
                try { //letar reda på vart spelet ligger på datorn
                    String tempFilePath = new File("Zelda").getAbsolutePath();
                    filePath = tempFilePath.substring(0, tempFilePath.lastIndexOf("Zelda"));
                } catch (SecurityException ex) {
                    System.out.println("!File access denied by OS or anti virus software!");
                }

                try { //lägger till bilder
                    wallSprite = ImageIO.read(new File(filePath + "\\sprites\\wall.png"));
                    hart = ImageIO.read(new File(filePath + "\\sprites\\hart.png"));
                    getToEgg = ImageIO.read(new File(filePath + "\\sprites\\gttge.png"));
                    startbtn = ImageIO.read(new File(filePath + "\\sprites\\start.png"));
                    restartbtn = ImageIO.read(new File(filePath + "\\sprites\\restart.png"));
                    gameOwer = ImageIO.read(new File(filePath + "\\sprites\\game_ower.png"));
                    egg = ImageIO.read(new File(filePath + "\\sprites\\egg.png"));
                    avoidBombs = ImageIO.read(new File(filePath + "\\sprites\\atb.png"));
                    wictory = ImageIO.read(new File(filePath + "\\sprites\\wictory.png"));

                } catch (IOException ex) {
                    System.out.println("!Could not find image at \"" + filePath + "sprites\"!");
                }
                textDocument = new File(filePath + "\\map.txt"); //läser in .txt filen
                screen = 0; //byter till nästa skerm
                repaint();
            }
            case 0 -> {
                if (evt.getX() > 300 && evt.getX() < 600 && evt.getY() > 200 && evt.getY() < 300) { //om knappen START klickats på
                    //---------------härifrån----------------
                    curentMap[0] = 1;
                    curentMap[1] = 1;
                    enemyPause = 0;
                    moveDirektion = 0;
                    enemies.clear();
                    try {
                        setMap("Ett");
                    } catch (FileNotFoundException ex) {
                        System.out.println("!Error while finding new room!");
                    }
                    setMapMap();
                    player.clear();
                    player.add(new Player(map));
                    //----------------till här--------------- återtäsl splplanen 
                    screen = 1; //byter skerm till spelplanen
                    //---------härifrån-----------
                    atempt++;
                    turns.add(new ArrayList());
                    turns.get(atempt).add(0);
                    //---------till hit----------- förbereds poängräknaren
                    ActionListener taskPerformer = new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            for (int i = 0; i < enemies.size(); i++) {
                                if (enemies.get(i).hit) { //om spelaren står i en explotion -> ta skada
                                    player.get(0).hp--;
                                    enemies.get(i).hit = false;
                                    if (player.get(0).hp < 1) { //om spelaren har 0 hp kvar -> byt till förlora skerm och sätt stegen jättehögt
                                        screen = 2;
                                        ((Timer) evt.getSource()).stop();
                                        turns.get(turns.size() - 1).add(atempt + 1);
                                        turns.get(turns.size() - 1).set(0, 99999999);
                                    }
                                }
                            }
                            if (curentMap[0] == 1 && curentMap[1] == 1 && player.get(0).pPos[0] == 13 && player.get(0).pPos[1] == 15) { //om spelaren tar egget -> byt till fins skerm
                                screen = 3;
                                ((Timer) evt.getSource()).stop();
                                turns.get(turns.size() - 1).add(atempt + 1);
                            }

                            turns.get(turns.size() - 1).set(0, turns.get(turns.size() - 1).get(0) + 1); // lägg till 1 till tur räknaren

                            switch (moveDirektion) { //flytta spelaren 
                                case 1 ->
                                    player.get(0).addPPosY(-1);
                                case 2 ->
                                    player.get(0).addPPosX(1);
                                case 3 ->
                                    player.get(0).addPPosY(1);
                                case 4 ->
                                    player.get(0).addPPosX(-1);
                            }

                            if (player.get(0).go != 0) { //om spelaren gått över kanten av ett rum till ett annat rum
                                try {
                                    uppdateMap();
                                } catch (FileNotFoundException ex) {
                                    System.out.println("!Error while uppdating map!");
                                }
                            }

                            switch (enemyPause) { //få fiender att röra sig varannan tur
                                case 0 -> {
                                    for (int i = 0; i < enemies.size(); i++) {
                                        enemies.get(i).enemyTurn();
                                    }
                                    enemyPause = 1;
                                }
                                case 1 ->
                                    enemyPause = 0;
                            }

                            moveDirektion = 0; //återsteller kapp tryck
                            repaint();
                        }
                    };
                    Timer timer = new Timer(200, taskPerformer); //skaper en timer som går av 5 gånger per sekund
                    timer.setRepeats(true); //setter timern så att den fortsätter
                    timer.start(); // startar timern
                }
            }
            case 1 -> {
                // Det här är spelplanen - inget ska hända när man trycker på skermen här
            }
            case 2 -> {
                if (evt.getX() > 300 && evt.getX() < 600 && evt.getY() > 200 && evt.getY() < 300) { //om Restart trycks -> gå tillbacka till start
                    screen = 0;
                }

            }
            case 3 -> {
                if (evt.getX() > 300 && evt.getX() < 600 && evt.getY() > 200 && evt.getY() < 300) { //om Restart trycks -> gå tillbacka till start
                    screen = 0;
                }
            }
            default ->
                System.out.println("!Screen set to an index that does not exist!");
        }
    }//GEN-LAST:event_formMouseClicked

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        int kod = evt.getKeyCode();

        switch (kod) { // vilken riktning går spelaren
            case KeyEvent.VK_UP -> {
                moveDirektion = 1;
            }
            case KeyEvent.VK_W -> {
                moveDirektion = 1;
            }
            case KeyEvent.VK_DOWN -> {
                moveDirektion = 3;
            }
            case KeyEvent.VK_S -> {
                moveDirektion = 3;
            }
            case KeyEvent.VK_LEFT -> {
                moveDirektion = 4;
            }
            case KeyEvent.VK_A -> {
                moveDirektion = 4;
            }
            case KeyEvent.VK_RIGHT -> {
                moveDirektion = 2;
            }
            case KeyEvent.VK_D -> {
                moveDirektion = 2;
            }
            default ->
                System.out.println("!Key not mapped!");
        }

        if (screen == -1) {
            try { //letar reda på vart spelet ligger på datorn
                String tempFilePath = new File("Zelda").getAbsolutePath();
                filePath = tempFilePath.substring(0, tempFilePath.lastIndexOf("Zelda"));
            } catch (SecurityException ex) {
                System.out.println("!File access denied by OS or anti virus software!");
            }

            try { //lägger till bilder
                wallSprite = ImageIO.read(new File(filePath + "\\sprites\\wall.png"));
                hart = ImageIO.read(new File(filePath + "\\sprites\\hart.png"));
                getToEgg = ImageIO.read(new File(filePath + "\\sprites\\gttge.png"));
                startbtn = ImageIO.read(new File(filePath + "\\sprites\\start.png"));
                restartbtn = ImageIO.read(new File(filePath + "\\sprites\\restart.png"));
                gameOwer = ImageIO.read(new File(filePath + "\\sprites\\game_ower.png"));
                egg = ImageIO.read(new File(filePath + "\\sprites\\egg.png"));
                avoidBombs = ImageIO.read(new File(filePath + "\\sprites\\atb.png"));
                wictory = ImageIO.read(new File(filePath + "\\sprites\\wictory.png"));

            } catch (IOException ex) {
                System.out.println("!Could not find image at \"" + filePath + "sprites\"!");
            }
            textDocument = new File(filePath + "\\map.txt"); //läser in .txt filen
            screen = 0; //byter till nästa skerm
            repaint();
        }

        repaint();
    }//GEN-LAST:event_formKeyPressed

    void setMapMap() { //skapar den tvådimentionella ArrayList som holler reda på vilken text i .txt filen som motsvarar till vilket rum på kartan
        mapMap.add(new ArrayList());
        mapMap.add(new ArrayList());
        mapMap.get(0).add("Fyra");
        mapMap.get(0).add("Två");
        mapMap.get(1).add("Tre");
        mapMap.get(1).add("Ett");

    }

    void uppdateMap() throws FileNotFoundException { //byter rum om spelaren går över kanten på ett rum
        switch (player.get(0).go) {
            case 1 -> {
                setMap(mapMap.get(curentMap[1]).get(curentMap[0] - 1));
                player.get(0).pPos[1] = wallLengthY - 1;
                curentMap[0] -= 1;
            }
            case 2 -> {
                setMap(mapMap.get(curentMap[1] + 1).get(curentMap[0]));
                player.get(0).pPos[0] = 0;
                curentMap[1] += 1;
            }
            case 3 -> {
                setMap(mapMap.get(curentMap[1]).get(curentMap[0] + 1));
                player.get(0).pPos[1] = 0;
                curentMap[0] += 1;
            }
            case 4 -> {
                setMap(mapMap.get(curentMap[1] - 1).get(curentMap[0]));
                player.get(0).pPos[0] = wallLengthX - 1;
                curentMap[1] -= 1;
            }
        }
        player.get(0).go = 0;
        newMonster(); //skapar nya monster i det nya rummet
    }

    void newMonster() { //skapar nya monster
        enemies.clear();
        int a = 3;
        switch (curentMap[0]) { //bestemer hur många monster som ska skapas beroende på vilket rum spelaren är i
            case 0 -> {
                switch (curentMap[1]) {
                    case 0 ->
                        a = 0;
                    case 1 ->
                        a = 3;
                }
            }

            case 1 -> {
                switch (curentMap[1]) {
                    case 0 ->
                        a = 2;
                    case 1 ->
                        a = 0;
                }
            }

        }

        for (int i = 0; i < a; i++) { //skapar a antal monster med random postitioner som inte ligger på spelaren
            int[] position = new int[2];
            do {
                position[0] = (int) (Math.random() * wallLengthX);
                position[1] = (int) (Math.random() * wallLengthY);
            } while (position[0] == player.get(0).pPos[0] || position[1] == player.get(0).pPos[1] || !walls(position));
            enemies.add(new Enemie(map, position, player.get(0).pPos));
        }
    }

    boolean walls(int[] pos) { //kollar om det ligger en vägg på en spesifik position
        if (pos[0] < 0 || pos[0] > wallLengthX - 1 || pos[1] < 0 || pos[1] > wallLengthY - 1) {
            return false;
        }
        return map.get(pos[1]).get(pos[0]) != 1;
    }

    void setMap(String s) throws FileNotFoundException { // läser in från .txt filen och skapar kartan
        Scanner txsc = new Scanner(textDocument);
        map.clear(); // tar bort den förra kartan
        String val = "[" + s + "]"; //bygger ihop en string som ska användas för att hitta i .txt filen

        //--------härifrån---------
        for (int i = 0; i < wallLengthY; i++) {
            map.add(new ArrayList<>());
        }
        for (int i = 0; i < wallLengthY; i++) {
            for (int j = 0; j < wallLengthX; j++) {
                map.get(i).add(0);
            }
        }
        //---------till hit--------- reserverar plats att lägga kartan

        txsc.findWithinHorizon(val, 100000);
        txsc.findWithinHorizon(val, 100000); //letar upp starten av karnan i .txt filen med hjälp av stringen man gett
        try {
            while (txsc.hasNextLine() && !txsc.next().equals("[Stop]")) { //läster av .txt filen till [Stop] kommer
                for (int i = 1; i < wallLengthY; i += 3) {
                    for (int j = 1; j < wallLengthX; j += 3) {
                        int temp = Integer.valueOf(txsc.next());
                        setMapPos(i, j, temp);
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("!Error while scanning map!");
        }

    }

    void setMapPos(int i, int j, int obj) { // gör så att en 9x9 ruta får vägg eller mark
        map.get(i).set(j, obj);
        map.get(i - 1).set(j, obj);
        map.get(i - 1).set(j - 1, obj);
        map.get(i - 1).set(j + 1, obj);
        map.get(i + 1).set(j, obj);
        map.get(i + 1).set(j - 1, obj);
        map.get(i + 1).set(j + 1, obj);
        map.get(i).set(j - 1, obj);
        map.get(i).set(j + 1, obj);

    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        switch (screen) {
            case -1 -> { //skermen i börgan

                g.drawString("Press anywhere to continue", 400, 600);
            }
            case 0 -> { //startskermen
                g.setColor(Color.black);
                g.fillRect(0, 0, 2000, 2000); //fyller i bakrunden
                g.drawImage(startbtn, 300, 200, 300, 100, this); //ritar knappen

                for (int i = turns.size() - 1; i >= 0; i--) { //sorterar den tvådimentionella ArrayListen med turer
                    for (int j = 0; j < i; j++) {
                        if (turns.get(j).get(0) > turns.get(j + 1).get(0)) {
                            ArrayList<Integer> temp = turns.get(j);
                            turns.set(j, turns.get(j + 1));
                            turns.set(j + 1, temp);

                        }
                    }
                }
                if (!turns.isEmpty()) { // om rutns inte är tom skriv score board
                    g.setColor(Color.LIGHT_GRAY);
                    g.fillRect(630, 300 - 50, 200, turns.size() * 30 + 60);
                    g.setColor(Color.red);
                    g.drawString("Score board", 650, 300 - 30);

                }
                for (int i = 0; i < turns.size(); i++) { //skriv ut hur det gick
                    int a = turns.get(i).get(0) + 1;
                    if (turns.get(i).get(0) > 9999999) { //om spelaren förlorade
                        String s = "Try " + turns.get(i).get(1) + ": Faliur";
                        g.drawString(s, 650, 300 + i * 30);

                    } else { //om spelaren tog sig till ägget
                        String s = "Try " + turns.get(i).get(1) + ": " + a + " turns to find the egg";
                        g.drawString(s, 650, 300 + i * 30);

                    }
                }
                int searchIndex = 0;
                for (int i = 0; i < turns.size(); i++) { //sök upp vilken tur som var bäst
                    if (turns.get(i).get(0) < turns.get(searchIndex).get(0)) {
                        searchIndex = i;
                    }
                }
                if (turns.size() > 1) {
                    g.drawString("the best try was: Try " + turns.get(searchIndex).get(1), 650, 300 + turns.size() * 30);

                }
            }
            case 1 -> { //spelplanen
                g.setColor(Color.black);
                g.fillRect(0, 0, 1000, 1000);
                boolean dontDraw = false;
                for (int i = 0; i < wallLengthY; i++) { //kollar på kartan och bestämmer vad som ska ritas ut
                    for (int j = 0; j < wallLengthX; j++) {
                        if (null == map.get(i).get(j)) {
                            g.setColor(Color.black);
                        } else {
                            switch (map.get(i).get(j)) {
                                case 0 -> //om det är mark
                                    g.setColor(Color.pink);
                                case 1 -> { //om det är vägg
                                    dontDraw = true;
                                    g.drawImage(wallSprite, j * 20, i * 20 + 125, 20, 20, this);
                                }
                                default ->
                                    g.setColor(Color.black);
                            }
                        }
                        if (!dontDraw) { //om det inte var vägg -> rita mark
                            g.fillRect(j * 20, i * 20 + 125, 20, 20);

                        }
                        dontDraw = false;
                    }
                }

                player.get(0).draw(g); //rita spelaren
                g.setColor(Color.black);
                g.fillRect(0, 0, 1000, 125); //skapar den svarta rutan åvanför planen
                g.drawImage(getToEgg, 200, 70, 600, 30, this); //ritar text
                g.drawImage(avoidBombs, 275, 20, 450, 30, this); //ritar text
                for (int i = 0; i < player.get(0).hp; i++) { //ritar i antal hjärtan beroende på hur mycket liv spelaren har
                    g.drawImage(hart, 50 + 40 * i, 70, 30, 30, this);
                }
                for (int i = 0; i < enemies.size(); i++) { //ritar fiender
                    enemies.get(i).draw(g);
                }
                if (curentMap[0] == 1 && curentMap[1] == 1) { //ritar ut ägget om spelaren är i rummet med ägget
                    g.drawImage(egg, 13 * 20 - 20, 15 * 20 + 125 - 20, 60, 60, this);
                }

            }

            case 2 -> { //om spelaren dog eller tog alldeles för long tid på sig
                g.setColor(Color.black);
                g.fillRect(0, 0, 2000, 2000);
                g.drawImage(gameOwer, 275, 400, this);
                g.drawImage(restartbtn, 300, 200, 300, 100, this); //ritar kanppen
            }
            case 3 -> { //om spelaren tog sig till ägget
                g.setColor(Color.black);
                g.fillRect(0, 0, 2000, 2000);
                g.drawImage(wictory, 310, 400, this);
                g.drawImage(restartbtn, 300, 200, 300, 100, this); //ritar knappen
            }
            default -> {
                System.out.println("!Screen set to an index that does not exist!");
            }
        }

    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
